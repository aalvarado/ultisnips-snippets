snippet #! "hash bang"
#!/usr/bin/ruby
endsnippet

snippet =b "begin rdoc"
=begin rdoc
  ${1}
=end
endsnippet

snippet require "require"
require '${1}'${2}
endsnippet

snippet case "case"
case ${1:object}
  when ${2:condition}
  ${3}
end
endsnippet

snippet when "when"
when ${1:condition}
  ${2}
endsnippet

snippet def "method def"
def ${1:method_name}
  ${2}${VISUAL}
end${3}
endsnippet

snippet init "initialize"
def initialize${1}
  ${2:#my method}
end${3}
endsnippet

snippet if "if"
if ${1:condition}
  ${2}${VISUAL}
end${3}
endsnippet

snippet ife "if-else"
if ${1:condition}
  ${2}
else
  ${3}
end${3}
endsnippet

snippet elsif "elsif"
elsif ${1:condition}
  ${2}
endsnippet

snippet unless "unless"
unless ${1:condition}
  ${2}
end
endsnippet

snippet while "while"
while ${1:condition}
  ${2}
end
endsnippet

snippet until "until"
until ${1:condition}
  ${2}
end
endsnippet

snippet class "class"
class ${1:ClassName}
  ${2}
end${3}
endsnippet

snippet cla "class with def"
class ${1}
  def initialize${2}
    ${3}
  end${4}
end
endsnippet

snippet attr "attribute writter"
attr_writter :${1:attr_names}
endsnippet

snippet attr "attribute reader"
attr_reader :${1:attr_names}
endsnippet

snippet attr "attribute accesor"
attr_accesor :${1:attr_names}
endsnippet

snippet attr_r "attr_reader"
attr_reader :${1:attr_names}
endsnippet

snippet attr_w "attr_writter"
attr_writer :${1:attr_names}
endsnippet

snippet attr_a "attr_accesor"
attr_accessor :${1:attr_names}
endsnippet

snippet Enum "enum def"
include Enumerable

def each(&block)
  ${1}
end
endsnippet

snippet Comp "include comparable"
include Comparable

def <=>(other)
  ${1}
end
endsnippet

snippet defs "define class method"
def self.${1}
  ${2}
end${3}
endsnippet

snippet defmm "define method missing"
def method_missing(meth, *args, &blk)
  ${1}
end
endsnippet

snippet defd "method delegator"
def_delegator :${1:@del_obj}, :${2:del_meth}, :${3:new_name}
endsnippet

snippet defds "method delegators"
def_delegators :${1:@del_obj}, :${2:del_methods}
endsnippet

snippet am "alias method"
alias_method :${1:new_name}, :${2:old_name}
endsnippet

snippet app "app"
if __FILE__ == $PROGRAM_NAME
  ${1}
end
endsnippet

snippet downto "downto" w
downto(${1:0}) { |${2:n}| ${3} }
endsnippet

snippet step "step" w
step(${1:2}) { |${2:n}| ${3} }
endsnippet

snippet times "times" w
times { |${1:n}| ${2} }
endsnippet

snippet upto "upto" w
upto(${1:1.0/0.0}) { |${2:n}| ${3} }
endsnippet

snippet each "each" w
each { |${1:e}| ${2} }
endsnippet

snippet inject "inject" w
inject(${1:init}) { |${2:mem}, ${3:var}| ${4} }
endsnippet

snippet map "map" w
map { |${1:e}| ${2} }
endsnippet

snippet scan "scan" w
scan(${1:/pattern/}) { |${2:match}| ${3} }
endsnippet

snippet max "max" w
max { |a, b|, ${1} }
endsnippet

snippet min "min" w
min { |a, b|, ${1} }
endsnippet

snippet lambda "lambda" w
lambda { |${1:args}| ${2} }
endsnippet

snippet testclass "test class"
require "test/unit"

require "${1:library_file_name}"

class Test${2:$1} < Test::Unit::TestCase
  def test_${3:case_name}
    ${4}
  end
end
endsnippet

snippet as "assert"
assert(${1:test}, "${2:Failure message.}")${3}
endsnippet

snippet ase "assert equal"
assert_equal(${1:expected}, ${2:actual})${3}
endsnippet

snippet logger "special logger"
logger.info "\n---------------"
logger.info $0
logger.info '---------------'
endsnippet

snippet puts "special puts"
puts "\n-------------"
puts $0${VISUAL}
puts '--------------'
endsnippet

snippet i18 "I18n.translation" w
I18n.t("${1}")${2}
endsnippet

snippet f.c "factory.create" w
Factory.create( ${1}${VISUAL} )
endsnippet

snippet namespace "namespace"
namespace :${1:my_namespace} do
  $0
end
endsnippet
snippet desc "describe" b
describe '${1}' do
  ${2}${VISUAL}
end
endsnippet
snippet it "it" b
it '${2}' do
	${3}${VISUAL}
end
endsnippet

snippet f.b "factory build" w
Factory.build( :${1} )
endsnippet

snippet # "var interpolation" i
#{${1}}${2}
endsnippet

snippet expect "expect" !b
expect(${1}${VISUAL})${2}
endsnippet

snippet let "let" !b
let(:${1}) { ${2}${VISUAL} }${3}
endsnippet

snippet llet "multline let" !b
let(:${1}) do
	${2}${VISUAL}
end${3}
endsnippet

snippet iit "single line it" !b
it { ${1}${VISUAL} }${2}
endsnippet

snippet allow "allow" !b
allow(${1}).to receive(${2})
endsnippet

snippet module "module" !b
module ${1}
	${2}
end
endsnippet

snippet b.p "binding.pry" !b
binding.pry
endsnippet

snippet do "surround do..end"
${1} do${2}
	${3}${VISUAL}
end${4}
endsnippet
